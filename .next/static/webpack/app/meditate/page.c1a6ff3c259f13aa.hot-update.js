"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/meditate/page",{

/***/ "(app-pages-browser)/./app/components/MeditationVisuals.tsx":
/*!**********************************************!*\
  !*** ./app/components/MeditationVisuals.tsx ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ MeditationVisuals; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var framer_motion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! framer-motion */ \"(app-pages-browser)/./node_modules/framer-motion/dist/es/render/components/motion/proxy.mjs\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nconst EMOJIS = [\n    \"✨\",\n    \"\\uD83C\\uDF1F\",\n    \"\\uD83D\\uDCAB\",\n    \"⭐\",\n    \"\\uD83C\\uDF19\",\n    \"☁️\",\n    \"\\uD83C\\uDF08\",\n    \"\\uD83C\\uDF38\",\n    \"\\uD83C\\uDF3A\",\n    \"\\uD83C\\uDF3C\"\n];\nconst COLORS = [\n    \"#FF6B6B\",\n    \"#4ECDC4\",\n    \"#FFD93D\",\n    \"#95E1D3\",\n    \"#FF8B94\",\n    \"#A8E6CF\",\n    \"#FFD3B6\",\n    \"#AA96DA\"\n];\n// Helper function to convert HSL to RGB\nfunction hslToRgb(h, s, l) {\n    s /= 100;\n    l /= 100;\n    const k = (n)=>(n + h / 30) % 12;\n    const a = s * Math.min(l, 1 - l);\n    const f = (n)=>l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));\n    return \"rgb(\".concat(Math.round(255 * f(0)), \", \").concat(Math.round(255 * f(8)), \", \").concat(Math.round(255 * f(4)), \")\");\n}\nfunction MeditationVisuals(param) {\n    let { isBreathingIn } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const particlesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const animationFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const lastTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const breathingPhaseRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        // Set canvas size\n        const resizeCanvas = ()=>{\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n        };\n        resizeCanvas();\n        window.addEventListener(\"resize\", resizeCanvas);\n        // Initialize particles\n        const initParticles = ()=>{\n            const particles = [];\n            const particleCount = Math.min(40, Math.floor(canvas.width * canvas.height / 20000));\n            const centerX = canvas.width / 2;\n            const centerY = canvas.height / 2;\n            const safeZoneRadius = Math.min(canvas.width, canvas.height) * 0.2;\n            for(let i = 0; i < particleCount; i++){\n                let x, y;\n                let attempts = 0;\n                const maxAttempts = 10;\n                do {\n                    x = Math.random() * canvas.width;\n                    y = Math.random() * canvas.height;\n                    attempts++;\n                }while (Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2)) < safeZoneRadius && attempts < maxAttempts);\n                const maxLife = 200 + Math.random() * 100;\n                const hue = Math.random() * 360;\n                const saturation = 70 + Math.random() * 30;\n                const brightness = 80 + Math.random() * 20;\n                particles.push({\n                    x,\n                    y,\n                    size: Math.random() * 8 + 6,\n                    speedX: (Math.random() - 0.5) * 1.2,\n                    speedY: (Math.random() - 0.5) * 1.2,\n                    opacity: Math.random() * 0.2 + 0.5,\n                    emoji: EMOJIS[Math.floor(Math.random() * EMOJIS.length)],\n                    rotation: Math.random() * 360,\n                    rotationSpeed: (Math.random() - 0.5) * 1.5,\n                    color: hslToRgb(hue, saturation, brightness),\n                    targetX: x,\n                    targetY: y,\n                    velocityX: 0,\n                    velocityY: 0,\n                    acceleration: 0.1 + Math.random() * 0.2,\n                    maxSpeed: 2 + Math.random() * 2,\n                    life: maxLife,\n                    maxLife,\n                    hue,\n                    saturation,\n                    brightness\n                });\n            }\n            particlesRef.current = particles;\n        };\n        initParticles();\n        // Animation loop\n        const animate = (timestamp)=>{\n            if (!ctx || !canvas) return;\n            const deltaTime = timestamp - lastTimeRef.current;\n            lastTimeRef.current = timestamp;\n            // Update breathing phase\n            breathingPhaseRef.current += deltaTime * 0.001;\n            const breathingValue = Math.sin(breathingPhaseRef.current) * 0.5 + 0.5;\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            const centerX = canvas.width / 2;\n            const centerY = canvas.height / 2;\n            const safeZoneRadius = Math.min(canvas.width, canvas.height) * 0.2;\n            const safeZoneBuffer = safeZoneRadius * 0.2;\n            particlesRef.current.forEach((particle)=>{\n                // Update particle life\n                particle.life -= deltaTime * 0.5;\n                if (particle.life <= 0) {\n                    particle.life = particle.maxLife;\n                    particle.x = Math.random() * canvas.width;\n                    particle.y = Math.random() * canvas.height;\n                }\n                // Calculate breathing effect\n                const breathingScale = isBreathingIn ? 1.2 : 0.9;\n                const currentSize = particle.size * breathingScale * (particle.life / particle.maxLife);\n                // Update target position based on breathing\n                const angle = Math.atan2(particle.y - centerY, particle.x - centerX);\n                const distance = Math.sqrt(Math.pow(particle.x - centerX, 2) + Math.pow(particle.y - centerY, 2));\n                if (distance < safeZoneRadius + safeZoneBuffer) {\n                    particle.targetX = centerX + Math.cos(angle) * (safeZoneRadius + safeZoneBuffer);\n                    particle.targetY = centerY + Math.sin(angle) * (safeZoneRadius + safeZoneBuffer);\n                } else {\n                    particle.targetX += (Math.random() - 0.5) * 2;\n                    particle.targetY += (Math.random() - 0.5) * 2;\n                }\n                // Organic movement using velocity and acceleration\n                const dx = particle.targetX - particle.x;\n                const dy = particle.targetY - particle.y;\n                const distanceToTarget = Math.sqrt(dx * dx + dy * dy);\n                if (distanceToTarget > 0.1) {\n                    particle.velocityX += dx / distanceToTarget * particle.acceleration;\n                    particle.velocityY += dy / distanceToTarget * particle.acceleration;\n                    // Limit velocity\n                    const currentSpeed = Math.sqrt(particle.velocityX * particle.velocityX + particle.velocityY * particle.velocityY);\n                    if (currentSpeed > particle.maxSpeed) {\n                        particle.velocityX = particle.velocityX / currentSpeed * particle.maxSpeed;\n                        particle.velocityY = particle.velocityY / currentSpeed * particle.maxSpeed;\n                    }\n                }\n                // Update position\n                particle.x += particle.velocityX;\n                particle.y += particle.velocityY;\n                particle.rotation += particle.rotationSpeed * (deltaTime / 16);\n                // Bounce off edges with damping\n                if (particle.x < 0 || particle.x > canvas.width) {\n                    particle.velocityX *= -0.8;\n                    particle.x = Math.max(0, Math.min(particle.x, canvas.width));\n                }\n                if (particle.y < 0 || particle.y > canvas.height) {\n                    particle.velocityY *= -0.8;\n                    particle.y = Math.max(0, Math.min(particle.y, canvas.height));\n                }\n                // Draw particle\n                ctx.save();\n                ctx.translate(particle.x, particle.y);\n                ctx.rotate(particle.rotation * Math.PI / 180);\n                // Draw multiple layers of glow\n                const glowLayers = 3;\n                for(let i = glowLayers; i > 0; i--){\n                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize * i);\n                    gradient.addColorStop(0, \"\".concat(particle.color).concat(Math.floor(30 / i)));\n                    gradient.addColorStop(1, \"transparent\");\n                    ctx.fillStyle = gradient;\n                    ctx.beginPath();\n                    ctx.arc(0, 0, currentSize * i, 0, Math.PI * 2);\n                    ctx.fill();\n                }\n                // Draw emoji with breathing effect\n                ctx.font = \"\".concat(currentSize, \"px Arial\");\n                ctx.textAlign = \"center\";\n                ctx.textBaseline = \"middle\";\n                ctx.globalAlpha = particle.opacity * (particle.life / particle.maxLife);\n                ctx.fillText(particle.emoji, 0, 0);\n                ctx.restore();\n            });\n            animationFrameRef.current = requestAnimationFrame(animate);\n        };\n        animationFrameRef.current = requestAnimationFrame(animate);\n        return ()=>{\n            window.removeEventListener(\"resize\", resizeCanvas);\n            if (animationFrameRef.current) {\n                cancelAnimationFrame(animationFrameRef.current);\n            }\n        };\n    }, [\n        isBreathingIn\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(framer_motion__WEBPACK_IMPORTED_MODULE_2__.motion.div, {\n        initial: {\n            opacity: 0\n        },\n        animate: {\n            opacity: 1\n        },\n        className: \"fixed inset-0 pointer-events-none\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n            ref: canvasRef,\n            className: \"w-full h-full\"\n        }, void 0, false, {\n            fileName: \"D:\\\\openmeditation\\\\app\\\\components\\\\MeditationVisuals.tsx\",\n            lineNumber: 256,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"D:\\\\openmeditation\\\\app\\\\components\\\\MeditationVisuals.tsx\",\n        lineNumber: 251,\n        columnNumber: 5\n    }, this);\n}\n_s(MeditationVisuals, \"wBOsSjonZqnH+b99lb9ZwNQXhcQ=\");\n_c = MeditationVisuals;\nvar _c;\n$RefreshReg$(_c, \"MeditationVisuals\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL01lZGl0YXRpb25WaXN1YWxzLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBRXlDO0FBQ0g7QUEwQnRDLE1BQU1HLFNBQVM7SUFBQztJQUFLO0lBQU07SUFBTTtJQUFLO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtDQUFLO0FBQ3pFLE1BQU1DLFNBQVM7SUFDYjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFRCx3Q0FBd0M7QUFDeEMsU0FBU0MsU0FBU0MsQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVM7SUFDL0NELEtBQUs7SUFDTEMsS0FBSztJQUNMLE1BQU1DLElBQUksQ0FBQ0MsSUFBYyxDQUFDQSxJQUFJSixJQUFJLEVBQUMsSUFBSztJQUN4QyxNQUFNSyxJQUFJSixJQUFJSyxLQUFLQyxHQUFHLENBQUNMLEdBQUcsSUFBSUE7SUFDOUIsTUFBTU0sSUFBSSxDQUFDSixJQUFjRixJQUFJRyxJQUFJQyxLQUFLRyxHQUFHLENBQUMsQ0FBQyxHQUFHSCxLQUFLQyxHQUFHLENBQUNKLEVBQUVDLEtBQUssR0FBR0UsS0FBS0MsR0FBRyxDQUFDLElBQUlKLEVBQUVDLElBQUk7SUFDcEYsT0FBTyxPQUFrQ0UsT0FBM0JBLEtBQUtJLEtBQUssQ0FBQyxNQUFNRixFQUFFLEtBQUksTUFBK0JGLE9BQTNCQSxLQUFLSSxLQUFLLENBQUMsTUFBTUYsRUFBRSxLQUFJLE1BQTJCLE9BQXZCRixLQUFLSSxLQUFLLENBQUMsTUFBTUYsRUFBRSxLQUFJO0FBQzdGO0FBRWUsU0FBU0csa0JBQWtCLEtBQTZDO1FBQTdDLEVBQUVDLGFBQWEsRUFBOEIsR0FBN0M7O0lBQ3hDLE1BQU1DLFlBQVlsQiw2Q0FBTUEsQ0FBb0I7SUFDNUMsTUFBTW1CLGVBQWVuQiw2Q0FBTUEsQ0FBYSxFQUFFO0lBQzFDLE1BQU1vQixvQkFBb0JwQiw2Q0FBTUE7SUFDaEMsTUFBTXFCLGNBQWNyQiw2Q0FB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R0FBRztRQUNUQyxTQUFTO1lBQUV0RCxTQUFTO1FBQUU7UUFDdEJhLFNBQVM7WUFBRWIsU0FBUztRQUFFO1FBQ3RCdUQsV0FBVTtrQkFFViw0RUFBQ3pGO1lBQ0MwRixLQUFLL0Y7WUFDTDhGLFdBQVU7Ozs7Ozs7Ozs7O0FBSWxCO0dBbE53QmhHO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9jb21wb25lbnRzL01lZGl0YXRpb25WaXN1YWxzLnRzeD9hNDRmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgbW90aW9uIH0gZnJvbSAnZnJhbWVyLW1vdGlvbidcblxuaW50ZXJmYWNlIFBhcnRpY2xlIHtcbiAgeDogbnVtYmVyXG4gIHk6IG51bWJlclxuICBzaXplOiBudW1iZXJcbiAgc3BlZWRYOiBudW1iZXJcbiAgc3BlZWRZOiBudW1iZXJcbiAgb3BhY2l0eTogbnVtYmVyXG4gIGVtb2ppOiBzdHJpbmdcbiAgcm90YXRpb246IG51bWJlclxuICByb3RhdGlvblNwZWVkOiBudW1iZXJcbiAgY29sb3I6IHN0cmluZ1xuICB0YXJnZXRYOiBudW1iZXJcbiAgdGFyZ2V0WTogbnVtYmVyXG4gIHZlbG9jaXR5WDogbnVtYmVyXG4gIHZlbG9jaXR5WTogbnVtYmVyXG4gIGFjY2VsZXJhdGlvbjogbnVtYmVyXG4gIG1heFNwZWVkOiBudW1iZXJcbiAgbGlmZTogbnVtYmVyXG4gIG1heExpZmU6IG51bWJlclxuICBodWU6IG51bWJlclxuICBzYXR1cmF0aW9uOiBudW1iZXJcbiAgYnJpZ2h0bmVzczogbnVtYmVyXG59XG5cbmNvbnN0IEVNT0pJUyA9IFsn4pyoJywgJ/CfjJ8nLCAn8J+SqycsICfirZAnLCAn8J+MmScsICfimIHvuI8nLCAn8J+MiCcsICfwn4y4JywgJ/CfjLonLCAn8J+MvCddXG5jb25zdCBDT0xPUlMgPSBbXG4gICcjRkY2QjZCJywgLy8gQ29yYWxcbiAgJyM0RUNEQzQnLCAvLyBUdXJxdW9pc2VcbiAgJyNGRkQ5M0QnLCAvLyBZZWxsb3dcbiAgJyM5NUUxRDMnLCAvLyBNaW50XG4gICcjRkY4Qjk0JywgLy8gUGlua1xuICAnI0E4RTZDRicsIC8vIExpZ2h0IEdyZWVuXG4gICcjRkZEM0I2JywgLy8gUGVhY2hcbiAgJyNBQTk2REEnLCAvLyBMYXZlbmRlclxuXVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBIU0wgdG8gUkdCXG5mdW5jdGlvbiBoc2xUb1JnYihoOiBudW1iZXIsIHM6IG51bWJlciwgbDogbnVtYmVyKTogc3RyaW5nIHtcbiAgcyAvPSAxMDBcbiAgbCAvPSAxMDBcbiAgY29uc3QgayA9IChuOiBudW1iZXIpID0+IChuICsgaCAvIDMwKSAlIDEyXG4gIGNvbnN0IGEgPSBzICogTWF0aC5taW4obCwgMSAtIGwpXG4gIGNvbnN0IGYgPSAobjogbnVtYmVyKSA9PiBsIC0gYSAqIE1hdGgubWF4KC0xLCBNYXRoLm1pbihrKG4pIC0gMywgTWF0aC5taW4oOSAtIGsobiksIDEpKSlcbiAgcmV0dXJuIGByZ2IoJHtNYXRoLnJvdW5kKDI1NSAqIGYoMCkpfSwgJHtNYXRoLnJvdW5kKDI1NSAqIGYoOCkpfSwgJHtNYXRoLnJvdW5kKDI1NSAqIGYoNCkpfSlgXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1lZGl0YXRpb25WaXN1YWxzKHsgaXNCcmVhdGhpbmdJbiB9OiB7IGlzQnJlYXRoaW5nSW46IGJvb2xlYW4gfSkge1xuICBjb25zdCBjYW52YXNSZWYgPSB1c2VSZWY8SFRNTENhbnZhc0VsZW1lbnQ+KG51bGwpXG4gIGNvbnN0IHBhcnRpY2xlc1JlZiA9IHVzZVJlZjxQYXJ0aWNsZVtdPihbXSlcbiAgY29uc3QgYW5pbWF0aW9uRnJhbWVSZWYgPSB1c2VSZWY8bnVtYmVyPigpXG4gIGNvbnN0IGxhc3RUaW1lUmVmID0gdXNlUmVmPG51bWJlcj4oMClcbiAgY29uc3QgYnJlYXRoaW5nUGhhc2VSZWYgPSB1c2VSZWY8bnVtYmVyPigwKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnRcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuXG5cbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgIGlmICghY3R4KSByZXR1cm5cblxuICAgIC8vIFNldCBjYW52YXMgc2l6ZVxuICAgIGNvbnN0IHJlc2l6ZUNhbnZhcyA9ICgpID0+IHtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoXG4gICAgICBjYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0XG4gICAgfVxuICAgIHJlc2l6ZUNhbnZhcygpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2l6ZUNhbnZhcylcblxuICAgIC8vIEluaXRpYWxpemUgcGFydGljbGVzXG4gICAgY29uc3QgaW5pdFBhcnRpY2xlcyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHBhcnRpY2xlczogUGFydGljbGVbXSA9IFtdXG4gICAgICBjb25zdCBwYXJ0aWNsZUNvdW50ID0gTWF0aC5taW4oNDAsIE1hdGguZmxvb3IoKGNhbnZhcy53aWR0aCAqIGNhbnZhcy5oZWlnaHQpIC8gMjAwMDApKVxuXG4gICAgICBjb25zdCBjZW50ZXJYID0gY2FudmFzLndpZHRoIC8gMlxuICAgICAgY29uc3QgY2VudGVyWSA9IGNhbnZhcy5oZWlnaHQgLyAyXG4gICAgICBjb25zdCBzYWZlWm9uZVJhZGl1cyA9IE1hdGgubWluKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCkgKiAwLjJcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0aWNsZUNvdW50OyBpKyspIHtcbiAgICAgICAgbGV0IHgsIHlcbiAgICAgICAgbGV0IGF0dGVtcHRzID0gMFxuICAgICAgICBjb25zdCBtYXhBdHRlbXB0cyA9IDEwXG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHggPSBNYXRoLnJhbmRvbSgpICogY2FudmFzLndpZHRoXG4gICAgICAgICAgeSA9IE1hdGgucmFuZG9tKCkgKiBjYW52YXMuaGVpZ2h0XG4gICAgICAgICAgYXR0ZW1wdHMrK1xuICAgICAgICB9IHdoaWxlIChcbiAgICAgICAgICBNYXRoLnNxcnQoTWF0aC5wb3coeCAtIGNlbnRlclgsIDIpICsgTWF0aC5wb3coeSAtIGNlbnRlclksIDIpKSA8IHNhZmVab25lUmFkaXVzICYmXG4gICAgICAgICAgYXR0ZW1wdHMgPCBtYXhBdHRlbXB0c1xuICAgICAgICApXG5cbiAgICAgICAgY29uc3QgbWF4TGlmZSA9IDIwMCArIE1hdGgucmFuZG9tKCkgKiAxMDBcbiAgICAgICAgY29uc3QgaHVlID0gTWF0aC5yYW5kb20oKSAqIDM2MFxuICAgICAgICBjb25zdCBzYXR1cmF0aW9uID0gNzAgKyBNYXRoLnJhbmRvbSgpICogMzBcbiAgICAgICAgY29uc3QgYnJpZ2h0bmVzcyA9IDgwICsgTWF0aC5yYW5kb20oKSAqIDIwXG5cbiAgICAgICAgcGFydGljbGVzLnB1c2goe1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICBzaXplOiBNYXRoLnJhbmRvbSgpICogOCArIDYsXG4gICAgICAgICAgc3BlZWRYOiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAxLjIsXG4gICAgICAgICAgc3BlZWRZOiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAxLjIsXG4gICAgICAgICAgb3BhY2l0eTogTWF0aC5yYW5kb20oKSAqIDAuMiArIDAuNSxcbiAgICAgICAgICBlbW9qaTogRU1PSklTW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIEVNT0pJUy5sZW5ndGgpXSxcbiAgICAgICAgICByb3RhdGlvbjogTWF0aC5yYW5kb20oKSAqIDM2MCxcbiAgICAgICAgICByb3RhdGlvblNwZWVkOiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAxLjUsXG4gICAgICAgICAgY29sb3I6IGhzbFRvUmdiKGh1ZSwgc2F0dXJhdGlvbiwgYnJpZ2h0bmVzcyksXG4gICAgICAgICAgdGFyZ2V0WDogeCxcbiAgICAgICAgICB0YXJnZXRZOiB5LFxuICAgICAgICAgIHZlbG9jaXR5WDogMCxcbiAgICAgICAgICB2ZWxvY2l0eVk6IDAsXG4gICAgICAgICAgYWNjZWxlcmF0aW9uOiAwLjEgKyBNYXRoLnJhbmRvbSgpICogMC4yLFxuICAgICAgICAgIG1heFNwZWVkOiAyICsgTWF0aC5yYW5kb20oKSAqIDIsXG4gICAgICAgICAgbGlmZTogbWF4TGlmZSxcbiAgICAgICAgICBtYXhMaWZlLFxuICAgICAgICAgIGh1ZSxcbiAgICAgICAgICBzYXR1cmF0aW9uLFxuICAgICAgICAgIGJyaWdodG5lc3NcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHBhcnRpY2xlc1JlZi5jdXJyZW50ID0gcGFydGljbGVzXG4gICAgfVxuXG4gICAgaW5pdFBhcnRpY2xlcygpXG5cbiAgICAvLyBBbmltYXRpb24gbG9vcFxuICAgIGNvbnN0IGFuaW1hdGUgPSAodGltZXN0YW1wOiBudW1iZXIpID0+IHtcbiAgICAgIGlmICghY3R4IHx8ICFjYW52YXMpIHJldHVyblxuXG4gICAgICBjb25zdCBkZWx0YVRpbWUgPSB0aW1lc3RhbXAgLSBsYXN0VGltZVJlZi5jdXJyZW50XG4gICAgICBsYXN0VGltZVJlZi5jdXJyZW50ID0gdGltZXN0YW1wXG5cbiAgICAgIC8vIFVwZGF0ZSBicmVhdGhpbmcgcGhhc2VcbiAgICAgIGJyZWF0aGluZ1BoYXNlUmVmLmN1cnJlbnQgKz0gZGVsdGFUaW1lICogMC4wMDFcbiAgICAgIGNvbnN0IGJyZWF0aGluZ1ZhbHVlID0gTWF0aC5zaW4oYnJlYXRoaW5nUGhhc2VSZWYuY3VycmVudCkgKiAwLjUgKyAwLjVcblxuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXG5cbiAgICAgIGNvbnN0IGNlbnRlclggPSBjYW52YXMud2lkdGggLyAyXG4gICAgICBjb25zdCBjZW50ZXJZID0gY2FudmFzLmhlaWdodCAvIDJcbiAgICAgIGNvbnN0IHNhZmVab25lUmFkaXVzID0gTWF0aC5taW4oY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KSAqIDAuMlxuICAgICAgY29uc3Qgc2FmZVpvbmVCdWZmZXIgPSBzYWZlWm9uZVJhZGl1cyAqIDAuMlxuXG4gICAgICBwYXJ0aWNsZXNSZWYuY3VycmVudC5mb3JFYWNoKHBhcnRpY2xlID0+IHtcbiAgICAgICAgLy8gVXBkYXRlIHBhcnRpY2xlIGxpZmVcbiAgICAgICAgcGFydGljbGUubGlmZSAtPSBkZWx0YVRpbWUgKiAwLjVcbiAgICAgICAgaWYgKHBhcnRpY2xlLmxpZmUgPD0gMCkge1xuICAgICAgICAgIHBhcnRpY2xlLmxpZmUgPSBwYXJ0aWNsZS5tYXhMaWZlXG4gICAgICAgICAgcGFydGljbGUueCA9IE1hdGgucmFuZG9tKCkgKiBjYW52YXMud2lkdGhcbiAgICAgICAgICBwYXJ0aWNsZS55ID0gTWF0aC5yYW5kb20oKSAqIGNhbnZhcy5oZWlnaHRcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBicmVhdGhpbmcgZWZmZWN0XG4gICAgICAgIGNvbnN0IGJyZWF0aGluZ1NjYWxlID0gaXNCcmVhdGhpbmdJbiA/IDEuMiA6IDAuOVxuICAgICAgICBjb25zdCBjdXJyZW50U2l6ZSA9IHBhcnRpY2xlLnNpemUgKiBicmVhdGhpbmdTY2FsZSAqIChwYXJ0aWNsZS5saWZlIC8gcGFydGljbGUubWF4TGlmZSlcblxuICAgICAgICAvLyBVcGRhdGUgdGFyZ2V0IHBvc2l0aW9uIGJhc2VkIG9uIGJyZWF0aGluZ1xuICAgICAgICBjb25zdCBhbmdsZSA9IE1hdGguYXRhbjIocGFydGljbGUueSAtIGNlbnRlclksIHBhcnRpY2xlLnggLSBjZW50ZXJYKVxuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChcbiAgICAgICAgICBNYXRoLnBvdyhwYXJ0aWNsZS54IC0gY2VudGVyWCwgMikgKyBNYXRoLnBvdyhwYXJ0aWNsZS55IC0gY2VudGVyWSwgMilcbiAgICAgICAgKVxuICAgICAgICBcbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgc2FmZVpvbmVSYWRpdXMgKyBzYWZlWm9uZUJ1ZmZlcikge1xuICAgICAgICAgIHBhcnRpY2xlLnRhcmdldFggPSBjZW50ZXJYICsgTWF0aC5jb3MoYW5nbGUpICogKHNhZmVab25lUmFkaXVzICsgc2FmZVpvbmVCdWZmZXIpXG4gICAgICAgICAgcGFydGljbGUudGFyZ2V0WSA9IGNlbnRlclkgKyBNYXRoLnNpbihhbmdsZSkgKiAoc2FmZVpvbmVSYWRpdXMgKyBzYWZlWm9uZUJ1ZmZlcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJ0aWNsZS50YXJnZXRYICs9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDJcbiAgICAgICAgICBwYXJ0aWNsZS50YXJnZXRZICs9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDJcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9yZ2FuaWMgbW92ZW1lbnQgdXNpbmcgdmVsb2NpdHkgYW5kIGFjY2VsZXJhdGlvblxuICAgICAgICBjb25zdCBkeCA9IHBhcnRpY2xlLnRhcmdldFggLSBwYXJ0aWNsZS54XG4gICAgICAgIGNvbnN0IGR5ID0gcGFydGljbGUudGFyZ2V0WSAtIHBhcnRpY2xlLnlcbiAgICAgICAgY29uc3QgZGlzdGFuY2VUb1RhcmdldCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSlcblxuICAgICAgICBpZiAoZGlzdGFuY2VUb1RhcmdldCA+IDAuMSkge1xuICAgICAgICAgIHBhcnRpY2xlLnZlbG9jaXR5WCArPSAoZHggLyBkaXN0YW5jZVRvVGFyZ2V0KSAqIHBhcnRpY2xlLmFjY2VsZXJhdGlvblxuICAgICAgICAgIHBhcnRpY2xlLnZlbG9jaXR5WSArPSAoZHkgLyBkaXN0YW5jZVRvVGFyZ2V0KSAqIHBhcnRpY2xlLmFjY2VsZXJhdGlvblxuXG4gICAgICAgICAgLy8gTGltaXQgdmVsb2NpdHlcbiAgICAgICAgICBjb25zdCBjdXJyZW50U3BlZWQgPSBNYXRoLnNxcnQoXG4gICAgICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eVggKiBwYXJ0aWNsZS52ZWxvY2l0eVggKyBwYXJ0aWNsZS52ZWxvY2l0eVkgKiBwYXJ0aWNsZS52ZWxvY2l0eVlcbiAgICAgICAgICApXG4gICAgICAgICAgaWYgKGN1cnJlbnRTcGVlZCA+IHBhcnRpY2xlLm1heFNwZWVkKSB7XG4gICAgICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eVggPSAocGFydGljbGUudmVsb2NpdHlYIC8gY3VycmVudFNwZWVkKSAqIHBhcnRpY2xlLm1heFNwZWVkXG4gICAgICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eVkgPSAocGFydGljbGUudmVsb2NpdHlZIC8gY3VycmVudFNwZWVkKSAqIHBhcnRpY2xlLm1heFNwZWVkXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHBvc2l0aW9uXG4gICAgICAgIHBhcnRpY2xlLnggKz0gcGFydGljbGUudmVsb2NpdHlYXG4gICAgICAgIHBhcnRpY2xlLnkgKz0gcGFydGljbGUudmVsb2NpdHlZXG4gICAgICAgIHBhcnRpY2xlLnJvdGF0aW9uICs9IHBhcnRpY2xlLnJvdGF0aW9uU3BlZWQgKiAoZGVsdGFUaW1lIC8gMTYpXG5cbiAgICAgICAgLy8gQm91bmNlIG9mZiBlZGdlcyB3aXRoIGRhbXBpbmdcbiAgICAgICAgaWYgKHBhcnRpY2xlLnggPCAwIHx8IHBhcnRpY2xlLnggPiBjYW52YXMud2lkdGgpIHtcbiAgICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eVggKj0gLTAuOFxuICAgICAgICAgIHBhcnRpY2xlLnggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihwYXJ0aWNsZS54LCBjYW52YXMud2lkdGgpKVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWNsZS55IDwgMCB8fCBwYXJ0aWNsZS55ID4gY2FudmFzLmhlaWdodCkge1xuICAgICAgICAgIHBhcnRpY2xlLnZlbG9jaXR5WSAqPSAtMC44XG4gICAgICAgICAgcGFydGljbGUueSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBhcnRpY2xlLnksIGNhbnZhcy5oZWlnaHQpKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRHJhdyBwYXJ0aWNsZVxuICAgICAgICBjdHguc2F2ZSgpXG4gICAgICAgIGN0eC50cmFuc2xhdGUocGFydGljbGUueCwgcGFydGljbGUueSlcbiAgICAgICAgY3R4LnJvdGF0ZSgocGFydGljbGUucm90YXRpb24gKiBNYXRoLlBJKSAvIDE4MClcblxuICAgICAgICAvLyBEcmF3IG11bHRpcGxlIGxheWVycyBvZiBnbG93XG4gICAgICAgIGNvbnN0IGdsb3dMYXllcnMgPSAzXG4gICAgICAgIGZvciAobGV0IGkgPSBnbG93TGF5ZXJzOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgZ3JhZGllbnQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoMCwgMCwgMCwgMCwgMCwgY3VycmVudFNpemUgKiBpKVxuICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBgJHtwYXJ0aWNsZS5jb2xvcn0ke01hdGguZmxvb3IoMzAgLyBpKX1gKVxuICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAndHJhbnNwYXJlbnQnKVxuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBncmFkaWVudFxuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgIGN0eC5hcmMoMCwgMCwgY3VycmVudFNpemUgKiBpLCAwLCBNYXRoLlBJICogMilcbiAgICAgICAgICBjdHguZmlsbCgpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBEcmF3IGVtb2ppIHdpdGggYnJlYXRoaW5nIGVmZmVjdFxuICAgICAgICBjdHguZm9udCA9IGAke2N1cnJlbnRTaXplfXB4IEFyaWFsYFxuICAgICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcidcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHBhcnRpY2xlLm9wYWNpdHkgKiAocGFydGljbGUubGlmZSAvIHBhcnRpY2xlLm1heExpZmUpXG4gICAgICAgIGN0eC5maWxsVGV4dChwYXJ0aWNsZS5lbW9qaSwgMCwgMClcbiAgICAgICAgXG4gICAgICAgIGN0eC5yZXN0b3JlKClcbiAgICAgIH0pXG5cbiAgICAgIGFuaW1hdGlvbkZyYW1lUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSlcbiAgICB9XG5cbiAgICBhbmltYXRpb25GcmFtZVJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2l6ZUNhbnZhcylcbiAgICAgIGlmIChhbmltYXRpb25GcmFtZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lUmVmLmN1cnJlbnQpXG4gICAgICB9XG4gICAgfVxuICB9LCBbaXNCcmVhdGhpbmdJbl0pXG5cbiAgcmV0dXJuIChcbiAgICA8bW90aW9uLmRpdlxuICAgICAgaW5pdGlhbD17eyBvcGFjaXR5OiAwIH19XG4gICAgICBhbmltYXRlPXt7IG9wYWNpdHk6IDEgfX1cbiAgICAgIGNsYXNzTmFtZT1cImZpeGVkIGluc2V0LTAgcG9pbnRlci1ldmVudHMtbm9uZVwiXG4gICAgPlxuICAgICAgPGNhbnZhc1xuICAgICAgICByZWY9e2NhbnZhc1JlZn1cbiAgICAgICAgY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbFwiXG4gICAgICAvPlxuICAgIDwvbW90aW9uLmRpdj5cbiAgKVxufSAiXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwibW90aW9uIiwiRU1PSklTIiwiQ09MT1JTIiwiaHNsVG9SZ2IiLCJoIiwicyIsImwiLCJrIiwibiIsImEiLCJNYXRoIiwibWluIiwiZiIsIm1heCIsInJvdW5kIiwiTWVkaXRhdGlvblZpc3VhbHMiLCJpc0JyZWF0aGluZ0luIiwiY2FudmFzUmVmIiwicGFydGljbGVzUmVmIiwiYW5pbWF0aW9uRnJhbWVSZWYiLCJsYXN0VGltZVJlZiIsImJyZWF0aGluZ1BoYXNlUmVmIiwiY2FudmFzIiwiY3VycmVudCIsImN0eCIsImdldENvbnRleHQiLCJyZXNpemVDYW52YXMiLCJ3aWR0aCIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJoZWlnaHQiLCJpbm5lckhlaWdodCIsImFkZEV2ZW50TGlzdGVuZXIiLCJpbml0UGFydGljbGVzIiwicGFydGljbGVzIiwicGFydGljbGVDb3VudCIsImZsb29yIiwiY2VudGVyWCIsImNlbnRlclkiLCJzYWZlWm9uZVJhZGl1cyIsImkiLCJ4IiwieSIsImF0dGVtcHRzIiwibWF4QXR0ZW1wdHMiLCJyYW5kb20iLCJzcXJ0IiwicG93IiwibWF4TGlmZSIsImh1ZSIsInNhdHVyYXRpb24iLCJicmlnaHRuZXNzIiwicHVzaCIsInNpemUiLCJzcGVlZFgiLCJzcGVlZFkiLCJvcGFjaXR5IiwiZW1vamkiLCJsZW5ndGgiLCJyb3RhdGlvbiIsInJvdGF0aW9uU3BlZWQiLCJjb2xvciIsInRhcmdldFgiLCJ0YXJnZXRZIiwidmVsb2NpdHlYIiwidmVsb2NpdHlZIiwiYWNjZWxlcmF0aW9uIiwibWF4U3BlZWQiLCJsaWZlIiwiYW5pbWF0ZSIsInRpbWVzdGFtcCIsImRlbHRhVGltZSIsImJyZWF0aGluZ1ZhbHVlIiwic2luIiwiY2xlYXJSZWN0Iiwic2FmZVpvbmVCdWZmZXIiLCJmb3JFYWNoIiwicGFydGljbGUiLCJicmVhdGhpbmdTY2FsZSIsImN1cnJlbnRTaXplIiwiYW5nbGUiLCJhdGFuMiIsImRpc3RhbmNlIiwiY29zIiwiZHgiLCJkeSIsImRpc3RhbmNlVG9UYXJnZXQiLCJjdXJyZW50U3BlZWQiLCJzYXZlIiwidHJhbnNsYXRlIiwicm90YXRlIiwiUEkiLCJnbG93TGF5ZXJzIiwiZ3JhZGllbnQiLCJjcmVhdGVSYWRpYWxHcmFkaWVudCIsImFkZENvbG9yU3RvcCIsImZpbGxTdHlsZSIsImJlZ2luUGF0aCIsImFyYyIsImZpbGwiLCJmb250IiwidGV4dEFsaWduIiwidGV4dEJhc2VsaW5lIiwiZ2xvYmFsQWxwaGEiLCJmaWxsVGV4dCIsInJlc3RvcmUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJkaXYiLCJpbml0aWFsIiwiY2xhc3NOYW1lIiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/MeditationVisuals.tsx\n"));

/***/ })

});